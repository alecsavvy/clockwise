package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"errors"

	"github.com/alecsavvy/clockwise/core"
	"github.com/alecsavvy/clockwise/core/db"
	"github.com/alecsavvy/clockwise/graph/model"
	"github.com/alecsavvy/clockwise/protocol/gen"
	"github.com/google/uuid"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	msg := &gen.CreateUser{
		Headers: &gen.Headers{
			Signature:   "sig",
			MessageType: gen.MessageType_MESSAGE_TYPE_CREATE_USER,
		},
		Data: &gen.CreateUser_Data{
			Handle:  input.Handle,
			Address: input.Address,
			Bio:     input.Bio,
		},
	}

	err := core.SendTx(r.logger, r.core.Rpc(), msg)
	if err != nil {
		return nil, err
	}

	resData, err := r.queries.GetUserData(ctx, input.Address)
	if err != nil {
		return nil, err
	}

	user := dbUserDataToUserModel(resData)
	return user, nil
}

// CreateTrack is the resolver for the createTrack field.
func (r *mutationResolver) CreateTrack(ctx context.Context, input model.NewTrack) (*model.Track, error) {
	msg := &gen.CreateTrack{
		Headers: &gen.Headers{
			Signature:   "sig",
			MessageType: gen.MessageType_MESSAGE_TYPE_CREATE_TRACK,
		},
		Data: &gen.CreateTrack_Data{
			Id:          uuid.NewString(),
			Title:       input.Title,
			StreamUrl:   input.StreamURL,
			Description: input.Description,
			UserId:      input.UserID,
		},
	}

	err := core.SendTx(r.logger, r.core.Rpc(), msg)
	if err != nil {
		return nil, err
	}

	trackRecord, err := r.queries.GetTrack(ctx, msg.Data.Id)
	if err != nil {
		return nil, err
	}

	track := &model.Track{
		ID:          trackRecord.ID,
		Title:       trackRecord.Title,
		StreamURL:   trackRecord.StreamUrl,
		Description: trackRecord.Description,
		UserID:      trackRecord.UserID,
	}

	return track, nil
}

// FollowUser is the resolver for the followUser field.
func (r *mutationResolver) FollowUser(ctx context.Context, input model.NewFollow) (*model.Follow, error) {
	msg := &gen.FollowUser{
		Headers: &gen.Headers{
			Signature:   "sig",
			MessageType: gen.MessageType_MESSAGE_TYPE_FOLLOW_USER,
		},
		Data: &gen.FollowUser_Data{
			FollowerId: input.FollowerID,
			FolloweeId: input.FolloweeID,
		},
	}

	err := core.SendTx(r.logger, r.core.Rpc(), msg)
	if err != nil {
		return nil, err
	}

	return &model.Follow{
		FollowerID: msg.Data.FollowerId,
		FolloweeID: msg.Data.FolloweeId,
	}, nil
}

// RepostTrack is the resolver for the repostTrack field.
func (r *mutationResolver) RepostTrack(ctx context.Context, input model.NewRepost) (*model.Repost, error) {
	msg := &gen.RepostTrack{
		Headers: &gen.Headers{
			Signature:   "sig",
			MessageType: gen.MessageType_MESSAGE_TYPE_REPOST_TRACK,
		},
		Data: &gen.RepostTrack_Data{
			ReposterId: input.ReposterID,
			TrackId:    input.TrackID,
		},
	}

	err := core.SendTx(r.logger, r.core.Rpc(), msg)
	if err != nil {
		return nil, err
	}

	return &model.Repost{
		ReposterID: msg.Data.ReposterId,
		TrackID:    msg.Data.TrackId,
	}, nil
}

// UnfollowUser is the resolver for the unfollowUser field.
func (r *mutationResolver) UnfollowUser(ctx context.Context, input model.NewUnfollow) (bool, error) {
	msg := &gen.UnfollowUser{
		Headers: &gen.Headers{
			Signature:   "sig",
			MessageType: gen.MessageType_MESSAGE_TYPE_UNFOLLOW_USER,
		},
		Data: &gen.UnfollowUser_Data{
			FollowerId: input.FollowerID,
			FolloweeId: input.FolloweeID,
		},
	}

	err := core.SendTx(r.logger, r.core.Rpc(), msg)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UnrepostTrack is the resolver for the unrepostTrack field.
func (r *mutationResolver) UnrepostTrack(ctx context.Context, input model.NewUnrepost) (bool, error) {
	msg := &gen.UnrepostTrack{
		Headers: &gen.Headers{
			Signature:   "sig",
			MessageType: gen.MessageType_MESSAGE_TYPE_UNREPOST_TRACK,
		},
		Data: &gen.UnrepostTrack_Data{
			ReposterId: input.ReposterID,
			TrackId:    input.TrackID,
		},
	}

	err := core.SendTx(r.logger, r.core.Rpc(), msg)
	if err != nil {
		return false, err
	}

	return true, nil
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context) ([]*model.User, error) {
	users, err := r.queries.GetUsers(ctx)
	if err != nil {
		return nil, err
	}
	return dbUserToUserModel(users), nil
}

// GetTracks is the resolver for the getTracks field.
func (r *queryResolver) GetTracks(ctx context.Context) ([]*model.Track, error) {
	tracks, err := r.queries.GetTracks(ctx)
	if err != nil {
		return nil, err
	}
	return dbTrackToTrackModel(tracks), nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, input model.GetUser) (*model.User, error) {
	if input.Address == nil && input.Handle == nil {
		return nil, errors.New("address or handle required")
	}

	handle := input.Handle
	address := input.Address

	if handle != nil {
		u, err := r.queries.GetUserByHandle(ctx, *handle)
		if err != nil {
			return nil, err
		}

		address = &u.ID
	}

	userData, err := r.queries.GetUserData(ctx, *address)
	if err != nil {
		return nil, err
	}

	user := dbUserDataToUserModel(userData)
	return user, nil
}

// GetTrack is the resolver for the getTrack field.
func (r *queryResolver) GetTrack(ctx context.Context, id string) (*model.Track, error) {
	track, err := r.queries.GetTrack(ctx, id)
	if err != nil {
		return nil, err
	}
	return dbTrackToTrackModel([]db.Track{track})[0], nil
}

// Tracks is the resolver for the tracks field.
func (r *subscriptionResolver) Tracks(ctx context.Context) (<-chan *model.Track, error) {
	tracksChannel := make(chan *model.Track)
	go func() {
		defer close(tracksChannel)
		newTracks := r.core.Pubsub().CreateTrackPubsub.Subscribe()
		for {
			select {
			case t, ok := <-newTracks:
				if !ok {
					return
				}
				newTrack := protoToTrackModel([]*gen.CreateTrack{t})[0]
				tracksChannel <- newTrack
			case <-ctx.Done():
				return
			}
		}
	}()
	return tracksChannel, nil
}

// Users is the resolver for the users field.
func (r *subscriptionResolver) Users(ctx context.Context) (<-chan *model.User, error) {
	usersChannel := make(chan *model.User)
	go func() {
		defer close(usersChannel)
		newUsers := r.core.Pubsub().CreateUserPubsub.Subscribe()
		for {
			select {
			case t, ok := <-newUsers:
				if !ok {
					return
				}
				newUser := protoToUserModel([]*gen.CreateUser{t})[0]
				usersChannel <- newUser
			case <-ctx.Done():
				return
			}
		}
	}()
	return usersChannel, nil
}

// Follows is the resolver for the follows field.
func (r *subscriptionResolver) Follows(ctx context.Context) (<-chan *model.Follow, error) {
	followsChannel := make(chan *model.Follow)
	go func() {
		defer close(followsChannel)
		newFollows := r.core.Pubsub().FollowUserPubsub.Subscribe()
		for {
			select {
			case t, ok := <-newFollows:
				if !ok {
					return
				}
				newFollow := protoToFollowModel([]*gen.FollowUser{t})[0]
				followsChannel <- newFollow
			case <-ctx.Done():
				return
			}
		}
	}()
	return followsChannel, nil
}

// Reposts is the resolver for the reposts field.
func (r *subscriptionResolver) Reposts(ctx context.Context) (<-chan *model.Repost, error) {
	repostsChannel := make(chan *model.Repost)
	go func() {
		defer close(repostsChannel)
		newReposts := r.core.Pubsub().RepostTrackPubsub.Subscribe()
		for {
			select {
			case t, ok := <-newReposts:
				if !ok {
					return
				}
				newRepost := protoToRepostModel([]*gen.RepostTrack{t})[0]
				repostsChannel <- newRepost
			case <-ctx.Done():
				return
			}
		}
	}()
	return repostsChannel, nil
}

// EntityUpdates is the resolver for the entityUpdates field.
func (r *subscriptionResolver) EntityUpdates(ctx context.Context) (<-chan model.Entity, error) {
	entitiesChannel := make(chan model.Entity)
	go func() {
		defer close(entitiesChannel)

		newUsers := r.core.Pubsub().CreateUserPubsub.Subscribe()
		newTracks := r.core.Pubsub().CreateTrackPubsub.Subscribe()
		newFollows := r.core.Pubsub().FollowUserPubsub.Subscribe()
		newReposts := r.core.Pubsub().RepostTrackPubsub.Subscribe()

		for {
			select {
			case e, ok := <-newUsers:
				if !ok {
					continue
				}
				newEntity := protoToUserModel([]*gen.CreateUser{e})[0]
				entitiesChannel <- newEntity
			case e, ok := <-newTracks:
				if !ok {
					continue
				}
				newEntity := protoToTrackModel([]*gen.CreateTrack{e})[0]
				entitiesChannel <- newEntity
			case e, ok := <-newFollows:
				if !ok {
					continue
				}
				newEntity := protoToFollowModel([]*gen.FollowUser{e})[0]
				entitiesChannel <- newEntity
			case e, ok := <-newReposts:
				if !ok {
					continue
				}
				newEntity := protoToRepostModel([]*gen.RepostTrack{e})[0]
				entitiesChannel <- newEntity
			case <-ctx.Done():
				return
			}
		}
	}()
	return entitiesChannel, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
